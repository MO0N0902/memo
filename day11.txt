day11
클래스 객체 생성자 오버로딩 this, this()

0. 객체지향언어(OOP)
	프로그램을 객체로 구성하고 이 객체들 간의 상호작용을 통해 문제를 해결하는 방식
	
1) 캡슐화
	객체의 데이터를 보호하고 외부에서 접근할 수 있는 방법을 제한하는 개념
	객체 데이터를 포함한 속성과 동작을 정의하는 메소드를 하나로 묶은것을 의미
	객체 외부에서 내부데이터를 직접 변경하지 못하게하고 허용된 메소드를 통해서만
	데이터를 변경하거나 사용할 수 있게한다
	
2) 다향성(polymorphism)
	다형성을 통해 같은 이름의 메소드가 객체에 따라 다르게 동작하도록 하는 것을 의미
	메소드 오버로딩, 메소드 오버라이딩, 참조변수의 다형성


3) 상속	
	기존 클래스의 필드와 메소드를 자식 클래스가 물려받는 상속을 지원한다
	상속은 extend 키워드를 사용한다
	단일 상속만 지원한다

4) 추상화
	불필요한 세부구현을 숨기고 중요한 부분만 노출하는 것을 의미한다
	추상 클래스
5) 클래스와 객체
	모든 데이터를 클래스의 형태로 정의하며 객체는 클래스의 인스턴스
	클래스는 객체의 설계도 역할을 하며 필드와 메소드를 정의한다

1. 클래스
	추상화된 클래스로 객체를 만들고 객체들 간의 관계를 맺어 상호작용하는 프로그래밍 기법
	추상화 ? 객체 모델링
		공통적인 특징을 파악하여 하나의 묶음으로 만들어 내는것

0) 
-클래스? 		비슷한 특징을 가진 것들을 몪어서 만든 일종의 설계도면
		사람들 설계도면 => 사람클래스

- 클래스 안에 있는것?		설계도면에 따라 만들어진 물건들을 위한 특징과 물건이 할 수 있는 행동
			사람클래스 => 필드 : 이름, 나이, 핸드폰번호, 혈액형, 주소, 주민번호
				메소드 : 걸을 수 있다, 문자를 보낼 수 있다, 잘수있다, 먹을 수 있다

속성 ? 	이름, 나이, 성별, 		 ==> 사람이 가지고 있는 특징
메소드? 	걷기, 말하기,먹기, 공부하기	 ==> 사람이 할 수 있는 행동
객체?	클래스를 만들면 그 설계도면에 따라 실제 물건을 만들 수 있다
	사람클래스 => 영선 객체명을 가진 사람을 만들 수 있고, 현택이라는 사람도 만들 수 있다

1) 클래스
- 사용자 정의 타입이다(자료형)
   클래스를 사용하면 여러 타입, 여러 값을 저장할 수 있는 저장 공간을 만들 수 있다
   클래스 안에 선언된 변수를 사용하고 싶다면 해당 클래스 타입으로 변수를 선언해야한다
   
   변수 : 하나의 자료형으로 하나의 값만 저장할 수 있는 저장공간
   배열 : 하나의 자료형으로 여러가지 값을 저장할 수 있는 저장공간

- 연관성 있는 저장공간과 기능을 한 곳에 모아 편하게 관리할 수 있는 것
   저장공간과 기능을 나누어 관리하게 되면 코드가 길어졌을 때 사용하기 불편한다
   이 때 연관되는 저장공간과 기능을 클래스로 묶어서 관리할 수 있다

- 객체를 생성하기 위한 틀, 설계도(면)
   공통되는 속성(변수)과 행위(메소드)를 한 번만 선언해 놓고 가져다 사용만 할 수 있도록 설계한다
   추상적인 것(클래스)를 구체화시키면(메모리에 생성된 것) 객체라고 한다

2) 객체(Object)와 인스턴스(Instance)
   객체 : 실제 사물 또는 개념
   클래스 : 객체를 컴퓨터에 옮기기 위해 추상화 한 것, 실제 존재하는 공간이 아니며 추상적이다
   인스턴스 : 클래스를 메모리에 할당시킨 것이며 물리적으로 존재하는 공간, 구체적이다

3) 클래스 선언
   class 클래스명{
      //class를 구성하는 필드와 메소드를 합쳐서 멤버라고 부른다
      필드;   //멤버변수, 전역변수

      메소드(){} //멤버메소드
   }

   객체화(인스턴스화)
      객체를 만드는 작업, 추상적인 개념을 구체화 시키는 작업
      클래스명 객체명 = new 클래스명();
      클래스명 참조변수명 = new 생성자();

   객체 사용 방법
      객체명.멤버명
      . : 하위연산자, 멤버접근연산자, 닷연산자



+) 객체를 생성하고 참조변수에 저장하는 과정
   class MyClass{
      void myMethod(){}
   }   

   public class Main{
      main(){
         MyClass    refVar    =      new MyClass();
         자료형(클래스)   참조변수   대입연산자      new 생성자();
         ----------------------   --------   --------------
            1번      3번      2번

      }
   }

2. 생성자
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않음
	생성자는 리턴이라는 기능이 존재하지 않는다
	객체가 생성될 때 자동으로 실행되며, 주로 클래스의 필드를 초기화하는 데 사용된다

1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다
	갹체 생성시 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으면 기본 생성자가 자동으로 추가된다
		-하지만 개발자가 생성자를 하나라도 정의하면 기본 생성자는 자동으로 만들어지지 않는다
2) 기본 생성자
	public 클래스명(){}
	매개변수가 없다
	클래스를 선언하면 자동으로 선언되며, 개발자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다.



3. this
	객체 자기자신을 의미한다 -> 객체 자신의 참조값을 담고있다
	this는 자동 생서오디는 변수이다

	* 현재 객체 자신을 참조하는 특별한 키워드 이고 클래스 내부에서 필드와 메소드를 가리킬 때 사용한다

1) this 키워드를 사용하는 이유
	필드와 지역변수 이름이 동일할 때  구분하기 위해서
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현

+) this : 객체 자기자신(참조값)

2) this의 좋은 사용법
	this를 활용해 의도를 명확히 하고 혼동을 방지
	this()를 활용해 중복코드제더 및 생성자 체이닝 구현

4. 다형성
	하나의 것이 여러 형태를 가질 수 있는 성질
	오버로딩 : 같은 이름으로 매개변수의 타입, 순서, 개수가 다른것을 선언하는 것이다
		메소드, 생성자
1) 생성자 오버로딩
	하나의 클래스에 여러 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수나 타입, 순서가 달라야한다
	
2) 기본 생성자 자동생성 조건
	사용자가 생성자를 정의하지 않은 경우 컴파일러jdk가 기본 생성자를 자동으로 추가한다
	하지만 사용자가 매개변수 가 있는 생성자를 정의하면 기본 생성자는 자동으로 만들어지지 않는다.

5.this()
	자기자신의 생성자를 의미한다
	생성자 내부에서만 사용 가능하며 최상단에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다



